<!-- TOC -->

- [List<T> list=new ArrayList<>()引发的思考](#listt-listnew-arraylist引发的思考)
    - [多态的概念](#多态的概念)
        - [向上转型](#向上转型)
        - [向下转型](#向下转型)
    - [接口编程](#接口编程)
        - [什么是面向接口编程](#什么是面向接口编程)
        - [为什么要面向接口编程](#为什么要面向接口编程)
        - [封闭 - 开放原则](#封闭---开放原则)

<!-- /TOC -->

# List<T> list=new ArrayList<>()引发的思考

## 多态的概念

多态--就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

比如，比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒…. 在这里我们可以描述成如下：

      酒 a = 剑南春

      酒 b = 五粮液

      酒 c = 酒鬼酒

这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态 —— 我们只有在运行的时候才会知道引用变量所指向的具体实例对象。

### 向上转型

在之前的例子中，通过`Wine a=new JNC();`在这里我们这样理解，这里定义了一个 Wine 类型的 a，它指向 JNC 对象实例。由于 JNC 是继承与 Wine，所以 JNC 可以自动向上转型为 Wine，所以 a 是可以指向 JNC 实例对象的。
```
public class Wine {
    public void fun1(){
        System.out.println("Wine 的Fun.....");
        fun2();
    }
    
    public void fun2(){
        System.out.println("Wine 的Fun2...");
    }
}

public class JNC extends Wine{
    /**
     * @desc 子类重载父类方法
     *        父类中不存在该方法，向上转型后，父类是不能引用该方法的
     * @param a
     * @return void
     */
    public void fun1(String a){
        System.out.println("JNC 的 Fun1...");
        fun2();
    }
    
    /**
     * 子类重写父类方法
     * 指向子类的父类引用调用fun2时，必定是调用该方法
     */
    public void fun2(){
        System.out.println("JNC 的Fun2...");
    }
}

public class Test {
    public static void main(String[] args) {
        Wine a = new JNC();
        a.fun1();
    }
}
-------------------------------------------------
Output:
Wine 的Fun.....
JNC 的Fun2...
```
指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于 ***子类中存在而父类中不存在的方法(子类单独定义的方法会丢失)*** `fun1(String a)`，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用 ***子类中定义***的这些方法（动态连接、动态调用）。

### 向下转型

与之相对应的就是向下转型。向下转型是把父类对象转为子类对象。但这里有个要注意的地方。
```
Animal a = new Cat();
Cat c = ((Cat) a);
c.eat();
//输出  我吃鱼
Dog d = ((Dog) a);
d.eat();
// 报错 ： java.lang.ClassCastException：com.chengfan.animal.Cat cannot be cast to com.chengfan.animal.Dog
Animal a1 = new Animal();
Cat c1 = ((Cat) a1);
c1.eat();
// 报错 ： java.lang.ClassCastException：com.chengfan.animal.Animal cannot be cast to com.chengfan.animal.Cat
```
因为 a 本身就是 Cat 对象，所以它理所当然的可以向下转型为 Cat，也理所当然的不能转为 Dog，你见过一条狗突然就变成一只猫这种操蛋现象？

而 a1 为 Animal 对象，它也不能被向下转型为任何子类对象。比如你去考古，发现了一个新生物，知道它是一种动物，但是你不能直接说，啊，它是猫，或者说它是狗。

***向下转型注意事项***

1. 向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型）
2. 向下转型只能转型为本类对象（猫是不能变成狗的）。

***
对于面向对象而言，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。

***在Java中，实现多态有两种方式，继承和接口。***


<div align="center">
<img src="../img/list.jpg" width="100%" >
</div>  

从图中可以看出，`ArrayList` 继承了`AbstractList`类，同时也实现了`List`接口。

在语句`List<T> list=new ArrayList<>();`中，`list`此时就是`List`这个接口的实例化对象了，它可以使用`List`接口中的方法。`ArrayList`独有的就不能用了，比如`arraylist.trimToSize()`方法就不能用。


那为什么一般都使用 `List list = new ArrayList ()` , 而不用 `ArrayList alist = new ArrayList ()` 呢?

问题就在于 `List` 有多个实现类，如 `LinkedList` 或者 `Vector` 等等，现在你用的是 ArrayList，也许哪一天你需要换成其它的实现类呢？，这时你只要改变这一行就行了：`List list = new LinkedList ()`; 其它使用了 `list` 地方的代码根本不需要改动。

假设你开始用 `ArrayList alist = new ArrayList ()`, 这下你有的改了，特别是如果你使用了 `ArrayList` 特有的方法和属性.如果没有特别需求的话，最好使用 `List list = new LinkedList ()`; , 便于程序代码的重构. 这就是面向接口编程的好处。

## 接口编程

我们经常会说面向对象编程，然后又提倡面向接口编程。其实不管是面向对象还是面向接口，本质上是一种程序实现的思想。面向对象编程有三大特性：封装、继承、多态。而接口编程就重复利用了这些特性。

### 什么是面向接口编程

>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的，对系统设计人员来讲就不那么重要了；而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。--百度

简单说就是尽量在类中做到只写接口或抽象类的名字，而不是具体某一个类的名字。

### 为什么要面向接口编程

1. 实现多态.
2. 减少耦合性.
3. 令各个成员依赖于抽象，而不是依赖于具体.
4. 方便维护和扩展.

其中最主要的就是第四点，便于维护和扩展。也是常说的 ***封闭 - 开放原则***

### 封闭 - 开放原则

所谓封闭开放原则就是：对修改封闭，对扩展开放。

当你写代码写到一半 (或者已经 release), 你的产品经理让你增加点或者修改某些东西。看起来只需要修改一点点东西，实际上如果类设计不好的话，可能会牵一发动全身。就是所谓的维护成本很大.其实根本的解决方法就是一开始，合理的设计类，应用合理的设计模式.

尽量做到，一旦有增加或者修改需求，我们都无需修改以前的类 (对修改封闭)，而只需增加 1 个新的类 (通常是子类，对扩展开放)

举个例子：

现在要实现一个投资者类，他可以买股票。
```
public class Invester{  
    public void buyStock(Stock s,int amount){  
        .....  
        s.buy(amount);  
        .....  
    }  
}  


public class Stock(){  
    public void buy(int amount){};  

 }  
```

然后过两天，需求改动，说还要能买基金`fund`。如果不使用接口，那就要新增一个基金类，在`Invester`里添加`buyfund()`方法。如果只是一个两个那倒也无所谓，可是如果要你增加期货，债券一大堆乱七八糟的，那这个`Invester`类里面就会很臃肿，也不符合 *对修改封闭* 原则。

那如何优化呢？这就可以用到接口了。

我们创建一个理财产品接口，然后让股票，期货，基金这些来实现这个接口。然后对于`Invester`来说，`buy`方法里只要满足这个接口就可以。
```
public class Invester{  
    public void buyInvest(Investable i,int amount){  
        .....  
        i.buy(amount);  
        .....  
    }  
}  


public class Stock() implements Investable{  
    @Override  
    public void buy(int amount){};  
}  

public interface Investable{  
    void buy(int amount);  
}  
```

最后分享一篇文章，里面就把接口编程说的很通俗易懂。

[为什么我们要面向接口编程？！](http://www.imooc.com/article/301555)
